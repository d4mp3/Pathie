---
alwaysApply: false
---

# DB Rules — Django + PostgreSQL (Hybrid Approach, Cursor Context)

## Kontekst projektu

Projekt korzysta z **Django ORM** do definiowania struktury danych (modele, relacje, kolumny, klucze),
oraz z **SQL layer** do definiowania niskopoziomowych mechanizmów bazy
(RLS, triggery, widoki, indeksy niestandardowe, materializacje).

---

## Główna zasada architektoniczna

> **Django ORM** = struktura danych
> **SQL layer** = logika bazodanowa, bezpieczeństwo i optymalizacja

W praktyce:

- Django opisuje modele i migracje strukturalne
- SQL pliki definiują logikę bazy i zasady bezpieczeństwa

---

## Zakres ORM (Django)

Zarządzane przez:

- `models.py`
- `migrations/`
- komendy `makemigrations` i `migrate`

ORM odpowiada za:

- tabele, relacje, klucze (`ForeignKey`, `ManyToManyField`, `OneToOneField`)
- typy danych (`UUIDField`, `ArrayField`, `JSONField`)
- walidacje i ograniczenia (`unique`, `choices`, `null`)
- definicje `on_delete`, `default`, `validators`
- dane startowe (`fixtures`, `loaddata`)

AI powinno:

- używać ORM tylko do definicji struktury
- **nie generować triggerów, polityk RLS ani widoków w kodzie Django**
- sugerować SQL tylko wtedy, gdy Django nie obsługuje danego mechanizmu

---

## Zakres SQL layer

Zarządzane przez:

- `migrations/postgres/`
- migracje Django z `RunSQL`
- ewentualnie katalog `db_scripts/` dla widoków i polityk

SQL służy do:

- **RLS (Row Level Security)**  

  ```sql
  -- Polityki właścicielskie (direct ownership)
  ALTER TABLE routes ENABLE ROW LEVEL SECURITY;
  CREATE POLICY user_can_access_own_routes ON routes
    FOR ALL USING (user_id = current_setting('app.user_id', true)::bigint);
  
  -- Polityki z dostępem pochodnym (przez relacje)
  CREATE POLICY access_via_parent ON child_table
    FOR ALL USING (
      EXISTS (
        SELECT 1 FROM parent_table p
        WHERE p.id = child_table.parent_id
          AND p.user_id = current_setting('app.user_id', true)::bigint
      )
    );
  ```

- **Triggery i funkcje PLpgSQL**  

  ```sql
  -- Funkcje pomocnicze (reusable)
  CREATE OR REPLACE FUNCTION set_updated_at()
  RETURNS TRIGGER AS $$
  BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  
  -- Triggery wymuszające logikę biznesową
  CREATE OR REPLACE FUNCTION enforce_item_limit()
  RETURNS TRIGGER AS $$
  DECLARE item_count int;
  BEGIN
    SELECT COUNT(*) INTO item_count 
    FROM items WHERE parent_id = NEW.parent_id AND is_active = true;
    IF item_count > 10 THEN
      RAISE EXCEPTION 'Limit exceeded';
    END IF;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
  
  -- Constraint triggers (DEFERRABLE) dla ograniczeń transakcyjnych
  CREATE CONSTRAINT TRIGGER enforce_min_max_count
  AFTER INSERT OR DELETE ON items
  DEFERRABLE INITIALLY DEFERRED
  FOR EACH ROW EXECUTE FUNCTION validate_count_range();
  ```

- **CHECK Constraints w SQL**

  Używaj dla krytycznych walidacji integralności danych (niezależnych od aplikacji):
  
  ```sql
  -- Enum-like values
  ALTER TABLE items ADD CONSTRAINT chk_status 
    CHECK (status IN ('draft', 'published', 'archived'));
  
  -- Range validation
  ALTER TABLE coords ADD CONSTRAINT chk_lat 
    CHECK (lat BETWEEN -90 AND 90);
  
  -- Multi-column dependencies
  ALTER TABLE bookings ADD CONSTRAINT chk_dates 
    CHECK (start_date < end_date);
  
  -- Conditional constraints
  ALTER TABLE items ADD CONSTRAINT chk_published_price
    CHECK (status != 'published' OR price > 0);
  ```

- **Widoki i materializowane widoki**

  ```sql
  CREATE MATERIALIZED VIEW user_stats AS
  SELECT user_id, COUNT(*) AS total FROM items GROUP BY user_id;
  
  -- Odświeżanie przez CRON/Celery
  REFRESH MATERIALIZED VIEW CONCURRENTLY user_stats;
  ```
  
- **Indeksy niestandardowe**

  ```sql
  -- UNIQUE PARTIAL (unikalność warunkowa)
  CREATE UNIQUE INDEX idx_unique_active
  ON items (user_id, code) WHERE is_active = true;
  
  -- Composite (dla częstych zapytań)
  CREATE INDEX idx_user_status_date
  ON items (user_id, status, created_at DESC);
  
  -- Functional (case-insensitive, etc.)
  CREATE UNIQUE INDEX idx_name_lower ON tags (lower(name));
  
  -- GIN dla full-text search
  CREATE INDEX idx_content_fts
  ON articles USING GIN (to_tsvector('simple', content));
  
  -- GIN dla JSONB/Array
  CREATE INDEX idx_metadata ON items USING GIN (metadata);
  ```

AI powinno:

- generować pliki .sql do katalogu migrations/sql/
- używać RunSQL w migracjach Django do ich dołączenia
- pisać SQL w sposób idempotentny (CREATE OR REPLACE, DROP IF EXISTS)

## Dobre praktyki

**ORM**

- utrzymuj spójność modeli z bazą (makemigrations, migrate)
- nie powielaj logiki bazy w Pythonie
- typy niestandardowe implementuj przez Field.db_type()
- walidacje domenowe trzymaj w warstwie Django, nie w triggerach

**SQL**

- każda zmiana logiczna w bazie = osobny plik .sql
- testuj triggery i RLS integracyjnie (np. pytest-django)
- nazwij obiekty konwencyjnie:
  - `rls_<table>_<policy>` — polityki RLS
  - `trg_<table>_<event>` — triggery
  - `fn_<name>` — funkcje PLpgSQL
  - `vw_<name>` — widoki
  - `mvw_<name>` — materialized views
  - `idx_<table>_<columns>` — indeksy
  - `chk_<table>_<constraint>` — CHECK constraints
- dodawaj `COMMENT ON` dla dokumentacji obiektów SQL

## Przykład integracji (migracja)

### migrations/0002_rls_policies.py

```python
from django.db import migrations

class Migration(migrations.Migration):
    dependencies = [
        ('routes', '0001_initial'),
    ]

    operations = [
        migrations.RunSQL(
            open('app/migrations/sql/0002_rls_policies.sql').read()
        ),
    ]
```

## Kontekst sesji (dla RLS)

RLS opiera się na kontekście użytkownika:

```sql
SET app.current_user_id = '<user_id>';
```

Backend (Django middleware lub DB wrapper) ustawia tę wartość
po zalogowaniu użytkownika. Dzięki temu polityki RLS działają dynamicznie.

## Cel podejścia

Hybrydowe podejście łączy czytelność ORM-u Django
z mocą PostgreSQL w zakresie bezpieczeństwa i logiki domenowej.

Korzyści:

- czysty ORM bez SQL w modelach
- pełna kontrola nad logiką bazy
- bezpieczeństwo dzięki RLS
- lepsza wydajność dzięki widokom i indeksom

## AI Context Hints (dla Cursor)

**Kiedy używać ORM:**
- Struktury danych (modele, relacje, typy kolumn)
- Standardowe ograniczenia (null, unique, default, basic validators)
- ORM może to wyrazić w models.py bez hacków, użyj ORM. Jeśli musisz napisać db_table z surowym SQL w docstringu jako "dokumentację" – to znak, że potrzebujesz raw SQL.

**Kiedy używać SQL layer:**
- Kontrola dostępu → RLS policies (direct ownership lub przez EXISTS)
- Automatyczne aktualizacje pól → triggery z funkcjami pomocniczymi
- Wymuszanie limitów biznesowych → triggery lub DEFERRABLE constraint triggers
- Walidacje krytyczne dla integralności → CHECK constraints w SQL
- Raporty/agregacje → widoki lub materialized views
- Unikalność warunkowa → UNIQUE PARTIAL indexes
- Wyszukiwanie full-text → indeksy GIN
- Case-insensitive unikalność → indeksy funkcjonalne (lower())
- Optymalizacja częstych zapytań → composite indexes

**Wskazówki szczegółowe:**
- „dodać logikę po zapisie/update" → trigger, nie post_save signal
- „kontrola dostępu na poziomie wierszy" → RLS (nie queryset filters)
- „tylko jeden aktywny X na użytkownika" → UNIQUE PARTIAL index
- „limit X elementów w relacji" → trigger lub DEFERRABLE constraint trigger
- „wyszukiwanie w treści" → GIN index z to_tsvector
- „agregacja/statystyki" → materialized view, nie queryset.aggregate()

**Przy generowaniu SQL:**
- Zawsze: `CREATE OR REPLACE`, `DROP IF EXISTS`, `COMMENT ON`
- Pliki w: `migrations/sql/`
- Integracja: `migrations.RunSQL()` z `reverse_sql`
- Utrzymuj zgodność ORM ↔ SQL (nie duplikuj definicji)
